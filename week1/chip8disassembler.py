from sys import argv, stdout

chip8OpCodes = {\
("0", "0", "E", "0") : "CLS",
("0", "0", "E", "E") : "RET",
("0")                : "SYS addr",
("1")                : "JP addr",
("2")                : "CALL addr",
("3")                : "SE Vx, byte",
("4")                : "SNE Vx, byte",
("5", "0")           : "SE Vx, Vy",
("6")                : "LD Vx, byte",
("7")                : "ADD Vx, byte",
("8", "0")           : "LD Vx, Vy",
("8", "1")           : "OR Vx, Vy",
("8", "2")           : "AND Vx, Vy",
("8", "3")           : "XOR Vx, Vy",
("8", "4")           : "ADD Vx, Vy",
("8", "5")           : "SUB Vx, Vy",
("8", "6")           : "SHR Vx {, Vy}",
("8", "7")           : "SUBN Vx, Vy",
("8", "E")           : "SHL Vx {, Vy}",
("9", "0")           : "SNE Vx, Vy",
("A")                : "LD I, addr",
("B")                : "JP V0, addr",
("C")                : "RND Vx, byte",
("D")                : "DRW Vx, Vy, nibble",
("E", "9", "E")      : "SKP Vx",
("E", "A", "1")      : "SKNP Vx",
("F", "0", "7")      : "LD Vx, DT",
("F", "0", "A")      : "LD Vx, K",
("F", "1", "5")      : "LD DT, Vx",
("F", "1", "8")      : "LD ST, Vx",
("F", "1", "E")      : "ADD I, Vx",
("F", "2", "9")      : "LD F, Vx",
("F", "3", "3")      : "LD B, Vx",
("F", "5", "5")      : "LD [I], Vx",
("F", "6", "5")      : "LD Vx, [I]"
}

def hexToOpCodes(hexStrings):
    """
    hexToOpCodes: Converts hex code to Chip-8 assembly nomenclature
    """
    final = []

    for everyHex in hexStrings:
        try:
            pattern = (everyHex[0])
            final.append(f'{chip8OpCodes[pattern]} <{everyHex[1:]}>')
        except:
            pass

        try:
            pattern = (everyHex[0], everyHex[3])
            final.append(f'{chip8OpCodes[pattern]} <{everyHex[1:2]}>')
        except:
            pass

        try:
            pattern = (everyHex[0], everyHex[2], everyHex[3])
            final.append(f'{chip8OpCodes[pattern]} <{everyHex[1]}>')
        except:
            pass

        try:
            pattern = (everyHex[0], everyHex[1], everyHex[2], everyHex[3])
            final.append(f'{chip8OpCodes[pattern]} <{everyHex[1:]}>')
        except:
            pass

    return final

def groupOpCodes(targetBinary):
    """
    groupOpCodes: Reads string of binary hex values and groups operation codes.
    """
    # Hold all OpCodes in order as read
    opCodes = []
    reader = 0
    for index in range(len(targetBinary)):

        # Guard against out of bounds
        if reader >= len(targetBinary):
            break

        # Empty string to build
        temp = ""
        temp += targetBinary[reader:reader + 2].upper()
        temp += targetBinary[reader + 2:reader + 4].upper()
        opCodes.append(temp)

        reader += 4

    return opCodes

def printHex(hexString):
    """
    printHex: Prints binary as hex, similar to Linux's hexdump.
    """
    reader = 0
    for everyOpCode in hexString:

        # Print out count of bytes
        if reader % 16 == 0:
            stdout.write(f'{hex(reader)[2:].zfill(7)} ')

        stdout.write(f'{everyOpCode} ')

        # Print new line after printing 8 pairs
        reader += 2
        if reader % 16 == 0:
            stdout.write(f'\n')

    stdout.write(f'\n')

def readBinary(file):
    """
    readBinary: Reads file as hexadecimal values.
    """
    temp = file.read().hex()
    file.close()

    return temp

def main():

    # Open binary
    targetBinary = open(argv[1], "rb")

    # Read as hexadecimal
    targetBinary = readBinary(targetBinary)
    # Fix endian order
    opCodes = groupOpCodes(targetBinary)
    printHex(opCodes)

    # Convert hex to opCodes
    opCodes = hexToOpCodes(opCodes)
    for every in opCodes:
        stdout.write(f'{every}\n')

if __name__ == "__main__":
    main()
