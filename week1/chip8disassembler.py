from sys import argv, stdout

'''
Chip-8 Instruction Set:

00E0 = CLS
00EE = RET
0nnn = SYS  addr
1nnn = JP   addr
2nnn = CALL addr
3xkk = SE   Vx, byte
4xkk = SNE  Vx, byte
5xy0 = SE   Vx, Vy
6xkk = LD   Vx, byte
7xkk = ADD  Vx, byte
8xy0 = LD   Vx, Vy
8xy1 = OR   Vx, Vy
8xy2 = AND  Vx, Vy
8xy3 = XOR  Vx, Vy
8xy4 = ADD  Vx, Vy
8xy5 = SUB  Vx, Vy
8xy6 = SHR  Vx {, Vy}
8xy7 = SUB  N Vx, Vy
8xyE = SHL  Vx {, Vy}
9xy0 = SNE  Vx, Vy
Annn = LD   I, addr
Bnnn = JP   V0, addr
Cxkk = RND  Vx, byte
Dxyn = DRW  Vx, Vy, nibble
Ex9E = SKP  Vx
ExA1 = SKNP Vx
Fx07 = LD   Vx, DT
Fx0A = LD   Vx, K
Fx15 = LD   DT, Vx
Fx18 = LD   ST, Vx
Fx1E = ADD  I, Vx
Fx29 = LD   F, Vx
Fx33 = LD   B, Vx
Fx55 = LD   [I], Vx
Fx65 = LD   Vx, [I]
'''

def hexToOpCodes(hexStrings):
    """
    hexToOpCodes: Converts hex code to Chip-8 assembly nomenclature
    """
    final = []

    memoryAddress = 512

    for everyOpCode in hexStrings:
        op, x, y, n = everyOpCode[0], everyOpCode[1], everyOpCode[2], everyOpCode[3]

        if everyOpCode == "00E0":
            final.append((memoryAddress, f'CLS ; Clear the screen'))

        elif everyOpCode == "00EE":
            final.append((memoryAddress, f'RET            ; Return from call'))

        elif op == "0":
            final.append((memoryAddress, f'SYS  {x}{y}{n}       ; System call'))

        elif op == "1":
            final.append((memoryAddress, f'JP   {x}{y}{n}       ; Jump to'))

        elif op == "2":
            final.append((memoryAddress, f'CALL {x}{y}{n}       ; Call procedure'))

        elif op == "3":
            final.append((memoryAddress, f'SE   V{x}, {y}{n}    ; TODO: Find documentation'))

        elif op == "4":
            final.append((memoryAddress, f'SNE  V{x}, {y}{n}    ; TODO: Find documentation'))

        elif op == "5" and n == 0:
            final.append((memoryAddress, f'SE   V{x}, V{y}      ; V{x} = V{y}'))

        elif op == "6":
            final.append((memoryAddress, f'LD   V{x}, {y}{n}    ; V{x} = {y}{n}'))

        elif op == "7":
            final.append((memoryAddress, f'ADD  V{x}, {y}{n}    ; V{x} += {y}{n}'))

        elif op == "8":
            if n == "0":
                final.append((memoryAddress, f'LD   V{x}, V{y}    ; V{x} = V{y}'))
            if n == "1":
                final.append((memoryAddress, f'OR   V{x}, V{y}    ; V{x} = V{x} | V{y}'))
            if n == "2":
                final.append((memoryAddress, f'AND  V{x}, V{y}    ; V{x} = V{x} & V{y}'))
            if n == "3":
                final.append((memoryAddress, f'XOR  V{x}, V{y}    ; V{x} = V{x} & V{y}'))
            if n == "4":
                final.append((memoryAddress, f'ADD  V{x}, V{y}    ; V{x} += V{y}'))
            if n == "5":
                final.append((memoryAddress, f'SUB  V{x}, V{y}    ; V{x} -= V{y}'))
            if n == "6":
                final.append((memoryAddress, f'SHR  V{x}, ' + '{, ' f'V{y}' + '}' + '  ; TODO: Find documentation'))
            if n == "7":
                final.append((memoryAddress, f'SUB  N V{x}, V{y}; TODO: Find documentation'))
            if n == "E":
                final.append((memoryAddress, f'SHL  V{x}, ' + '{, ' f'V{y}' + '}' + '  ; TODO: Find documentation'))

        elif op == "9" and n == "0":
            final.append((memoryAddress, f'SNE  V{x}, V{y}      ; TODO: Find documentation'))

        elif op == "A":
            final.append((memoryAddress, f'LD   I, {x}{y}{n}    ; I = {x}{y}{n}'))

        elif op == "B":
            final.append((memoryAddress, f'JP   V0, {x}{y}{n}   ; TODO: Find documentation'))

        elif op == "C":
            final.append((memoryAddress, f'RND  V{x}, {y}{n}    ; V{x} = RND({y}{n})'))

        elif op == "D":
            final.append((memoryAddress, f'DRW  V{x}, V{y}, {n} ; Draw {n} on (V{x},V{y})'))

        elif op == "E":
            y += n
            if y == "9E":
                final.append((memoryAddress, f'SKP  V{x}        ;'))

            elif y == "A1":
                final.append((memoryAddress, f'SKNP V{x}        ;'))

        elif op == "F":
            y += n
            if y == "07":
                final.append((memoryAddress, f'LD   V{x}, DT    ;'))
            elif y == "0A":
                final.append((memoryAddress, f'LD   V{x}, {y}   ; V{x} = {y}'))
            elif y == "15":
                final.append((memoryAddress, f'LD   DT, V{x}    ;'))
            elif y == "18":
                final.append((memoryAddress, f'LD   ST, V{x}    ;'))
            elif y == "1E":
                final.append((memoryAddress, f'ADD  I, V{x}     ; I += V{x}'))
            elif y == "29":
                final.append((memoryAddress, f'LD   F, V{x}     ; F = V{x}'))
            elif y == "33":
                final.append((memoryAddress, f'LD   B, V{x}     ; B = V{x}'))
            elif y == "55":
                final.append((memoryAddress, f'LD   [I], V{x}   ; *I = V{x}'))
            elif y == "65":
                final.append((memoryAddress, f'LD   V{x}, [I]   ; V{x} = *I'))

        else:
            final.append((memoryAddress, f'{everyOpCode}; UNEXPECTED OPERATION CODE\n'))

        memoryAddress += 16

    return final

def groupOpCodes(targetBinary):
    """
    groupOpCodes: Reads string of binary hex values and groups operation codes.
    """
    # Hold all OpCodes in order as read
    opCodes = []
    reader = 0
    for index in range(len(targetBinary)):

        # Guard against out of bounds
        if reader >= len(targetBinary):
            break

        # Empty string to build
        temp = ""
        temp += targetBinary[reader:reader + 2].upper()
        temp += targetBinary[reader + 2:reader + 4].upper()
        opCodes.append(temp)

        reader += 4

    return opCodes

def printHex(hexString):
    """
    printHex: Prints binary as hex, similar to Linux's hexdump.
    """
    reader = 0
    for everyOpCode in hexString:

        # Print out count of bytes
        if reader % 16 == 0:
            stdout.write(f'{hex(reader)[2:].zfill(7)} ')

        stdout.write(f'{everyOpCode} ')

        # Print new line after printing 8 pairs
        reader += 2
        if reader % 16 == 0:
            stdout.write(f'\n')

    stdout.write(f'\n')

def printOpCodes(opCodes):
    """
    printOpCodes: Prints list of Operation Codes.
    """
    reader = 0
    for every in opCodes:
        stdout.write(f'0x{hex(every[0])[2:].zfill(7)}: {every[1]}\n')

    stdout.write(f'\n')

def readBinary(file):
    """
    readBinary: Reads file as hexadecimal values.
    """
    temp = file.read().hex()
    file.close()

    return temp

def main():

    # Open binary
    targetBinary = open(argv[1], "rb")

    # Read as hexadecimal
    targetBinary = readBinary(targetBinary)
    # Group hexcode into opcodes
    opCodes = groupOpCodes(targetBinary)
    # printHex(opCodes)

    # Convert hex to opCodes
    opCodes = hexToOpCodes(opCodes)
    printOpCodes(opCodes)

if __name__ == "__main__":
    main()
