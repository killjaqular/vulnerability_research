from sys import argv, stdout

'''
Chip-8 Instruction Set:

00E0 = CLS
00EE = RET
0nnn = SYS  addr
1nnn = JP   addr
2nnn = CALL addr
3xkk = SE   Vx, byte
4xkk = SNE  Vx, byte
5xy0 = SE   Vx, Vy
6xkk = LD   Vx, byte
7xkk = ADD  Vx, byte
8xy0 = LD   Vx, Vy
8xy1 = OR   Vx, Vy
8xy2 = AND  Vx, Vy
8xy3 = XOR  Vx, Vy
8xy4 = ADD  Vx, Vy
8xy5 = SUB  Vx, Vy
8xy6 = SHR  Vx {, Vy}
8xy7 = SUB  N Vx, Vy
8xyE = SHL  Vx {, Vy}
9xy0 = SNE  Vx, Vy
Annn = LD   I, addr
Bnnn = JP   V0, addr
Cxkk = RND  Vx, byte
Dxyn = DRW  Vx, Vy, nibble
Ex9E = SKP  Vx
ExA1 = SKNP Vx
Fx07 = LD   Vx, DT
Fx0A = LD   Vx, K
Fx15 = LD   DT, Vx
Fx18 = LD   ST, Vx
Fx1E = ADD  I, Vx
Fx29 = LD   F, Vx
Fx33 = LD   B, Vx
Fx55 = LD   [I], Vx
Fx65 = LD   Vx, [I]
'''

def hexToOpCodes(hexStrings):
    """
    Converts hex code to Chip-8 assembly nomenclature
    """
    final = []

    memoryAddress = 512

    for everyOpCode in hexStrings:
        op, x, y, n = everyOpCode[0], everyOpCode[1], everyOpCode[2], everyOpCode[3]

        A = everyOpCode[:2]
        B = everyOpCode[2:]

        if everyOpCode == "00E0":
            final.append((memoryAddress, f'{A} {B} 00 EO CLS              ; Clear the screen'))

        elif everyOpCode == "00EE":
            final.append((memoryAddress, f'{A} {B} 00 EE RET        ; Return to address on stack'))

        elif op == "0":
            final.append((memoryAddress, f'{A} {B} SYS  0x{x}{y}{n}UNKNOWN; UNKNOWN'))

        elif op == "1":
            final.append((memoryAddress, f'{A} {B} JP   0x{x}{y}{n}       ; Jump to'))

        elif op == "2":
            final.append((memoryAddress, f'{A} {B} CALL 0x{x}{y}{n}       ; Call procedure'))

        elif op == "3":
            final.append((memoryAddress, f'{A} {B} SE   V{x}, 0x{y}{n}    ;'))

        elif op == "4":
            final.append((memoryAddress, f'{A} {B} SNE  V{x}, 0x{y}{n}    ;'))

        elif op == "5" and n == 0:
            final.append((memoryAddress, f'{A} {B} SE   V{x}, V{y}      ; V{x} = V{y}'))

        elif op == "6":
            final.append((memoryAddress, f'{A} {B} LD   V{x}, 0x{y}{n}    ; V{x} = 0x{y}{n}'))

        elif op == "7":
            final.append((memoryAddress, f'{A} {B} ADD  V{x}, 0x{y}{n}    ; V{x} += 0x{y}{n}'))

        elif op == "8":
            if n == "0":
                final.append((memoryAddress, f'{A} {B} LD   V{x}, V{y}      ; V{x} = V{y}'))
            if n == "1":
                final.append((memoryAddress, f'{A} {B} OR   V{x}, V{y}      ; V{x} = V{x} | V{y}'))
            if n == "2":
                final.append((memoryAddress, f'{A} {B} AND  V{x}, V{y}      ; V{x} = V{x} & V{y}'))
            if n == "3":
                final.append((memoryAddress, f'{A} {B} XOR  V{x}, V{y}      ; V{x} = V{x} & V{y}'))
            if n == "4":
                final.append((memoryAddress, f'{A} {B} ADD  V{x}, V{y}      ; V{x} += V{y}'))
            if n == "5":
                final.append((memoryAddress, f'{A} {B} SUB  V{x}, V{y}      ; V{x} -= V{y}'))
            if n == "6":
                final.append((memoryAddress, f'{A} {B} SHR  V{x}, ' + '{, ' f'V{y}' + '}' + '  ;'))
            if n == "7":
                final.append((memoryAddress, f'{A} {B} SUB  N V{x}, V{y};'))
            if n == "E":
                final.append((memoryAddress, f'{A} {B} SHL  V{x}, ' + '{, ' f'V{y}' + '}' + '  ;'))

        elif op == "9" and n == "0":
            final.append((memoryAddress, f'{A} {B} SNE  V{x}, V{y}      ;'))

        elif op == "A":
            final.append((memoryAddress, f'{A} {B} LD   I,  0x{x}{y}{n}   ; I = 0x{x}{y}{n}'))

        elif op == "B":
            final.append((memoryAddress, f'{A} {B} JP   V0, 0x{x}{y}{n}   ;'))

        elif op == "C":
            final.append((memoryAddress, f'{A} {B} RND  V{x}, 0x{y}{n}    ; V{x} = RND(0x{y}{n})'))

        elif op == "D":
            final.append((memoryAddress, f'{A} {B} DRW  V{x}, V{y}, 0x{n} ; Draw 0x{n} on (V{x},V{y})'))

        elif op == "E":
            y += n
            if y == "9E":
                final.append((memoryAddress, f'{A} {B} SKP  V{x}          ;'))

            elif y == "A1":
                final.append((memoryAddress, f'{A} {B} SKNP V{x}          ;'))
            else:
                final.append((memoryAddress, f'{A} {B} UNKNOWN OPCODE   ; UNKNOWN'))

        elif op == "F":
            y += n
            if y == "07":
                final.append((memoryAddress, f'{A} {B} LD   V{x}, DT      ;'))
            elif y == "0A":
                final.append((memoryAddress, f'{A} {B} LD   V{x}, 0x{y}   ; V{x} = 0x{y}'))
            elif y == "15":
                final.append((memoryAddress, f'{A} {B} LD   DT, V{x}      ;'))
            elif y == "18":
                final.append((memoryAddress, f'{A} {B} LD   ST, V{x}      ;'))
            elif y == "1E":
                final.append((memoryAddress, f'{A} {B} ADD  I, V{x}       ; I += V{x}'))
            elif y == "29":
                final.append((memoryAddress, f'{A} {B} LD   F, V{x}       ; F = V{x}'))
            elif y == "33":
                final.append((memoryAddress, f'{A} {B} LD   B, V{x}       ; B = V{x}'))
            elif y == "55":
                final.append((memoryAddress, f'{A} {B} LD   [I], V{x}     ; *I = V{x}'))
            elif y == "65":
                final.append((memoryAddress, f'{A} {B} LD   V{x}, [I]     ; V{x} = *I'))
            else:
                final.append((memoryAddress, f'{A} {B} UNKNOWN OPCODE   ; UNKNOWN'))

        else:
            final.append((memoryAddress, f'{A} {B} UNKNOWN OPCODE   ; UNKNOWN'))

        memoryAddress += 2

    return final

def groupOpCodes(targetBinary):
    """
    Reads string of binary hex values and groups operation codes.
    """
    # Hold all OpCodes in order as read
    opCodes = []
    reader = 0
    for index in range(len(targetBinary)):

        # Guard against out of bounds
        if reader >= len(targetBinary):
            break

        # Empty string to build
        temp = ""
        temp += targetBinary[reader:reader + 2].upper()
        temp += targetBinary[reader + 2:reader + 4].upper()
        opCodes.append(temp)

        reader += 4

    return opCodes

def printHex(hexString):
    """
    Prints binary as hex, similar to Linux's hexdump.
    """
    reader = 0
    for everyOpCode in hexString:

        # Print out count of bytes
        if reader % 16 == 0:
            stdout.write(f'{hex(reader)[2:].zfill(7)} ')

        stdout.write(f'{everyOpCode} ')

        # Print new line after printing 8 pairs
        reader += 2
        if reader % 16 == 0:
            stdout.write(f'\n')

    stdout.write(f'\n')

def printOpCodes(opCodes):
    """
    Prints list of Operation Codes.
    """
    reader = 0
    for every in opCodes:
        stdout.write(f'0x{hex(every[0])[2:].zfill(3)}: {every[1]}\n')

    stdout.write(f'\n')

def readBinary(file):
    """
    Reads file as hexadecimal values.
    """
    fileAsHexCode = file.read().hex()
    file.close()

    return fileAsHexCode

def main():

    # Open binary
    targetBinary = open(argv[1], "rb")

    # Read as hexadecimal
    targetBinary = readBinary(targetBinary)
    # Group hexcode into opcodes
    opCodes = groupOpCodes(targetBinary)
    printHex(opCodes)

    # Convert hex to opCodes
    opCodes = hexToOpCodes(opCodes)
    printOpCodes(opCodes)

if __name__ == "__main__":
    main()
