/*
Use the necessary tools to perform analysis of the compiled source code generated. Since we
are working in 32-bit use “-m32” for your gcc compilation options. For compilation I would
suggest using compiler option “-fno-stack-protector” and “-z execstack”. Please submit
write-ups of your analysis. Your points will be based on completeness of analysis, your
understanding of the problems, and if you were able to achieve the goals.

To compile:
gcc -m32 -fno-stack-protector -z execstack file.c -o file

Problem 1: 10pts
Cause the CFD to the function winner

run program in GDB and use:
NOTE: using python3 requires to write byte literals like this: b'this will turn to bytes'
r $(python -c "print(('A' * (4 + 4 + 64)) + 'B' * (4 + 4) + 'TARGET ADDRESS')")
to measure where to land your input into EIP

In an instance of gdb ./problem1, winner was found at address:
0x565561cd
\xcd\x61\x55\x56
*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/types.h>

struct data{
    char name[64]; //64 bytes
};

struct fp{
    int (*fp)(); //12 bytes
};

void winner(){
    printf("\nlevel passed\n");
}

int nowinner(){
    printf("\nlevel has not been passed\n");
}

int main(int argc, char** argv){
    struct data *d; //4
    struct fp *f; //4

    d = malloc(sizeof(struct data)); //4 previous, 4 size, 64 payload, 72
    f = malloc(sizeof(struct fp)); //4 previous, 4 size, 12 payload, 20
    f->fp = nowinner;

    printf("data is at %p, fp is at %p\n", d, f);

    strcpy(d->name, argv[1]);

    printf("data is at %p, fp is at 0x%x, Winner@ %p, NoWinner@ %p\n",
            d, f->fp, winner, nowinner);

    printf("%s", d->name);
    f->fp();

    return 0;
}
