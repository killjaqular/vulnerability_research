/*
Adonay Pichardo, adonaypichardo@gmail.com

@description
Assignment 2 of 2022 Spring Vulnerability Research at Florida Tech.

Problem 1:
Compile the below program; open in disassembler and compare source code with assembled
instructions.

Examine the disassembly:
1. Can you identify the integer overflow?
    The integer overflow occurs with the variable "nBytesRead". When poFile is closed with
    fclose(poFile), the stream is now advanced to the EOF marker of that stream.
    ftell(poFile) will return -1 and save it into nBytesRead. -1 evaluated as an unsigned
    long, is 0xFFFFFFFF. When comparing an unsigned variable to an int literal like 0, the
    unsigned variable will be implicitly cast to a signed int. Any bit set in nBytesRead
    will be interpreted as being greater than 0.

2. Can you cause the overflow to happen?
    Yes. Simply giving the program a valid file stream to read via argv[1], of any size,
    will always cause -1 to be set into nBytesRead by ftell() after an fclose() call.

*/

#include <stdio.h>

void ParseFileHdr(char* pcFileName){
    FILE* poFile;
    char abHdr[100];
    unsigned long nBytesRead;

    // open the file
    if((poFile = fopen(pcFileName, "rb"))){
        // Move the pointer by reading the data
        fread(abHdr, sizeof(char), 100, poFile);
        fclose(poFile);

        // Get File Position after read
        nBytesRead = ftell(poFile);
        printf("BytesRead: %d 0x%08x\n", nBytesRead, nBytesRead);

        if(nBytesRead > 0){
            printf("Oops Reading Header!\n");
        }

    }else{
        printf("Unable to Open File!\n");
    }
}

int main(int argv, char** argc){
    ParseFileHdr(argc[1]);
    return 0;
}
